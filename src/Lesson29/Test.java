package Lesson29;

public class Test {
    public static void main(String[] args) {
        //    Полиморфизм - способность метода обрабатывать данные разных типов
        //    перед изучением советую повторить наследование и интерфейсы
        Animal animal = new Animal();
        Animal animal1 = new Dog(); // через переменную типа Animal (родительского) мы смогли обратиться к объекту класса Dog
        Cat cat = new Cat();
        animal1.eat();  //есть доступ к eat()
        //animal1.bark(); //нет доступа к bark() когда мы обращаемся через родительский тип, мы имеем доступ определенный только в родителе

        animal.eat();
        //dog.eat(); //у объекта класса Dog есть метод eat() только потому что он унаследовал его от родительского класса Animal

        Dog dog = new Dog();
        dog.eat();  //есть доступ к eat()
        dog.bark(); //есть доступ к bark()

//Позднее связывание
// При данном создании объекта Animal animal1 = new Dog(); через родителя.
// При вызове animal1.eat() будет вызван метод у потомка, потому что у него переопределен метод eat() родителя (Animal).
// Если бы у потомка не было переопределения метода, то был бы вызван метод eat() родителя.

        test(animal);
        test(dog);
        test(cat);

    }
//    Удобство полиморфизма - способность передавать в метод разные типы, елси у них есть один и тот же родитель
    public static void test(Animal animal){
        animal.eat();
//Сделали один метод, который обслуживает общего родителя и передаётся потомкам, у одного из которых метод переопределён и работает по-своему
//код меньше и многоразовый.
// Если бы полиморфизма не было, то пришлось бы для каждого класса делать свой метод.
    }

}
