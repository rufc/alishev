package Lesson32;
//Восходящее и нисходящее преобразование
public class Test {
    public static void main(String[] args) {
//        Upcasting - восходящее преобразование. Потому что Dog наследуется от Animal.
        Animal animal = new Dog(); // декларируем переменную типа Animal, но присваиваем ей объект класса Dog (урок про Полиморфизм)
//или можно так и в итоге наша собака стала животным, ушла вверх по иерархии наследования, из собаки в общее животное:
        Dog dog = new Dog();
        Animal animal1 = dog;
//        Upcasting происходит неявно

//        Downcasting - нисходящее преобразование.
//        Происходит явно, то есть вручную
//        Чтобы из животного получить собаку, которая в нём лежит нужно явно указать,
//        что в этой переменной Animal лежит объект класса Dog в скобочках
                Dog dog2 = (Dog) animal1;
                dog2.bark(); // выполняется метод собаки
//Нисходящее преобразование не всегда безопасен
//смоделируем ситуацию при которой у нас появится ошибка
        Animal a = new Animal();
//        Dog dog1 = a; // создали переменную типа Dog и попробуем сослать объект класса Animal на переменную типа Dog
        //снова видим ошибку incompatible types и скажем Java что мы в курсе и что думаем что в переменной типа Animal лежит объект класса Dog
        Dog dog1 = (Dog) a; // и теперь Java думает что в переменной dog типа Dog лежит собака, хотя на самом деле объект у нас Animal
//        то есть эти преобразования не меняют объект, они меняют ссылку на этот объект
//        теперь пробуем вызвать у переменной типа Dog метод bark() и его там нет, потому что объект у нас Animal.
//        dog1.bark(); выдаст ошибку .ClassCastException, объект класса Animal не может быть преобразован в объект класса Dog.
//        В переменной типа Animal может лежать собака, а может лежать какое-то общее животное, у которого нет метода bark().
    }
}
